SPACE = _{ " " | "\t" | NEWLINE }
COMMENT = { "#" ~ (!NEWLINE ~ ANY)* }
FLAT_SPACE = _{ " " | "\t" }
number = { ASCII_DIGIT+ }

word_bound = _{ SPACE+ | !(ASCII_ALPHANUMERIC | "_" | "-" | "$" | "/") }
word = { (ASCII_ALPHANUMERIC)+ }
word_list = { FLAT_SPACE* ~ word ~ (SPACE+ ~ word)* }
assign_word = @{ #name = word ~ "=" ~ #value = word }
sep = { (" " | "\t")* ~ (";" | NEWLINE)+ ~ (" " | "\t")* }


command = { (shell_cmd ~ redir_list?) | expr }

simple_cmd_part = { redir | assign_word | word }
simple_cmd = { #cmd = (redir|assign_word|word) ~ (FLAT_SPACE+ ~ (redir|assign_word|word)?)* }

pipeline = { ((shell_cmd ~ redir_list?) | simple_cmd) ~ ("|" ~ FLAT_SPACE* ~ ((shell_cmd ~ redir_list?) | simple_cmd))+ }
expr = { pipeline | ((shell_cmd ~ redir_list?) | simple_cmd) }

and = { "&&" }
or = { "||" }

cmd_list = {
	expr ~ FLAT_SPACE* ~ (#op = (and|or) ~ FLAT_SPACE* ~ expr)*
}

redir_list = { redir ~ (FLAT_SPACE+ ~ redir)+ }
redir = {
	(">" ~ FLAT_SPACE* ~ #file = word) |
	("<" ~ FLAT_SPACE* ~ #file = word) |
	(#fd_out = number ~ "<" ~ FLAT_SPACE* ~ #file = word) |
	(#fd_out = number ~ ">" ~ FLAT_SPACE* ~ #file = word) |
	(">>" ~ FLAT_SPACE* ~ #file = word) |
	(#fd_out = number ~ ">>" ~ FLAT_SPACE* ~ #file = word) |
	("<<" ~ FLAT_SPACE* ~ #file = word) |
	("<<<" ~ FLAT_SPACE* ~ #file = word) |
	(#fd_out = number ~ "<<" ~ FLAT_SPACE* ~ #file = word) |
	("<&" ~ FLAT_SPACE* ~ #fd_target = number) |
	(#fd_out = number ~ "<&" ~ #fd_target = number) |
	(">&" ~ FLAT_SPACE* ~ number) |
	(#fd_out = number ~ ">&" ~ #fd_target = number) |
	(">&" ~ FLAT_SPACE* ~ "-") |
	(#fd_out = number ~ ">&" ~ FLAT_SPACE* ~ "-") |
	(#fd_out = number ~ "<&" ~ FLAT_SPACE* ~ "-") |
	("&>" ~ FLAT_SPACE* ~ #file = word) |
	(#fd_out = number ~ "<>" ~ FLAT_SPACE* ~ #file = word) |
	("<>" ~ FLAT_SPACE* ~ #file = word) |
	(">|" ~ FLAT_SPACE* ~ #file = word) |
	(#fd_out = number ~ ">|" ~ FLAT_SPACE* ~ #file = word)
}


shell_cmd = {
	for_cmd |
	match_cmd |
	loop_cmd |
	if_cmd |
	subshell |
	brace_grp |
	func_def
}

subsh_body = { (nested|non_paren)+ }
nested = _{ "(" ~ subsh_body* ~ ")"? }
non_paren = _{ (!"(" ~ !")" ~ ANY)+ }
subshell = @{ "(" ~ #body = subsh_body ~ ")" }

loop_kind = { while | until }
loop_cmd = { loop_kind ~ SPACE* ~ #cond = cmd_list ~ sep ~ do ~ SPACE* ~ (#body = cmd_list ~ sep)+ ~ done }

for_cmd = { for ~ SPACE+ ~ #vars = word ~ (SPACE+ ~ !"in" ~ word)+ ~ SPACE+ ~ in ~ SPACE+ ~ #arr = cmd_list ~ sep ~ do ~ (#body = cmd_list ~ sep)+ ~ done }

match_pat = { (!"=>" ~ word)+ }
match_body = { (brace_grp ~ ","? | (!"," ~ ANY)+ ~ ",") }
match_arm = { match_pat ~ FLAT_SPACE* ~ "=>" ~ SPACE* ~ match_body }
match_cmd = {
	"match" ~ FLAT_SPACE* ~ #var = word ~ SPACE+ ~ "in" ~ SPACE+ ~ match_arm ~ (SPACE* ~ match_arm)* ~ SPACE* ~ "done"
}


if = ${ FLAT_SPACE* ~ "if" ~ word_bound }
then = ${ FLAT_SPACE* ~ "then" ~ word_bound }
elif = ${ FLAT_SPACE* ~ "elif" ~ word_bound }
else = ${ FLAT_SPACE* ~ "else" ~ word_bound }
fi = ${ FLAT_SPACE* ~ "fi" ~ word_bound }

for = ${ FLAT_SPACE* ~ "for" ~ word_bound }
in = ${ FLAT_SPACE* ~ "in" ~ word_bound }
while = ${ FLAT_SPACE* ~ "while" ~ word_bound }
until = ${ FLAT_SPACE* ~ "until" ~ word_bound }
do = ${ FLAT_SPACE* ~ "do" ~ word_bound }
done = ${ FLAT_SPACE* ~ "done" ~ word_bound }

if_cmd = { if ~ FLAT_SPACE+ ~ #cond = cmd_list ~ sep ~ then ~ SPACE* ~ (#if_body = cmd_list ~ sep)+ ~ elif_block* ~ else_block? ~ fi }
elif_block = { elif ~ cmd_list ~ sep ~ then ~ SPACE+ ~ (#elif_body = cmd_list ~ sep)+ }
else_block = { else ~ SPACE+ ~ (#else_body = cmd_list ~ sep)+ }

func_def = { word ~ "()" ~ SPACE* ~ brace_grp }

brace_grp = { "{" ~ SPACE* ~ cmd_list ~ (sep ~ cmd_list)* ~ SPACE* ~ "}" }

main = { SOI ~ cmd_list? ~ (sep ~ cmd_list?)* ~ EOI }
