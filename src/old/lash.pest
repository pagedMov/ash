SPACE = _{ " " | "\t" | NEWLINE }
COMMENT = { "#" ~ (!(NEWLINE|"#") ~ ANY)* }
FLAT_SPACE = _{ " " | "\t" }
number = { ASCII_DIGIT+ }
parameter = { "#" | ASCII_DIGIT+ | "@" | "*" | "?" | "$" | "!" | "_" | "-" }

dqt = _{ "\"" }
sqt = _{ "'" }
word_bound = _{ !ident }
string_body = { ("\\\""|!"\"" ~ ANY)* }
dquoted = _{ dqt ~ string_body ~ dqt }
squoted = _{ sqt ~ string_body ~ sqt }
var_ident = @{ SPACE* ~ !parameter ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-")* }
ident = _{ (("\\" ~ ANY) | (!out ~ !in ~ ASCII_ALPHANUMERIC | "\"" | "'" | "_" | "-" | "!" | "?" | "%" | "+" | "=" | "$" | "\\" | "[" | "]" | "/" | "," | "." | ":" | "@" | "*" ))+ }
word = { dquoted | squoted | ident }
word_list = @{ FLAT_SPACE* ~ word ~ (SPACE+ ~ word)* }
assignment = ${ #name = var_ident ~ "=" ~ #value = word? ~ (FLAT_SPACE+ ~ expr)? }
sep = { FLAT_SPACE* ~ (";" | NEWLINE)+ ~ FLAT_SPACE* }

simple_cmd_part = { proc_sub | redir | word }
simple_cmd = { #cmd = (redir|word) ~ ((FLAT_SPACE* ~ proc_sub|redir) | (FLAT_SPACE+ ~ (assignment | word | redir | proc_sub)))* }

pipeline = { ((shell_cmd ~ redir_list?) | simple_cmd) ~ ("|" ~ FLAT_SPACE* ~ ((shell_cmd ~ redir_list?) | simple_cmd))+ }
expr = _{ pipeline | ((shell_cmd ~ redir_list?) | assignment | simple_cmd) }

and = { "&&" }
or = { "||" }

cmd_list = {
	expr ~ FLAT_SPACE* ~ (#op = (and|or) ~ FLAT_SPACE* ~ expr)*
}

redir_list = { FLAT_SPACE* ~ redir ~ (FLAT_SPACE* ~ redir)* }
fd_out = @{ number }
fd_target = @{ number }
file = @{ word }
in = { "<" }
out = { ">" }
force_out = { ">|" }
in_out = { "<>" }
append = { ">>" }
heredoc = { "<<" }
herestring = { "<<<" }
redir = {
	(out ~ FLAT_SPACE* ~ file) |
	(in ~ FLAT_SPACE* ~ file) |
	(fd_out ~ in ~ FLAT_SPACE* ~ file) |
	(fd_out ~ out ~ FLAT_SPACE* ~ file) |
	(append ~ FLAT_SPACE* ~ file) |
	(fd_out ~ append ~ FLAT_SPACE* ~ file) |
	(heredoc ~ FLAT_SPACE* ~ file) |
	(herestring ~ FLAT_SPACE* ~ file) |
	(fd_out ~ heredoc ~ FLAT_SPACE* ~ file) |
	(in ~ "&" ~ FLAT_SPACE* ~ fd_target) |
	(fd_out ~ in ~ "&" ~ fd_target) |
	(out ~ "&" ~ FLAT_SPACE* ~ fd_target) |
	(fd_out ~ out ~ "&" ~ fd_target) |
	(out ~ "&" ~ FLAT_SPACE* ~ "-") |
	(fd_out ~ out ~ "&" ~ FLAT_SPACE* ~ "-") |
	(fd_out ~ out ~ "&" ~ FLAT_SPACE* ~ "-") |
	("&" ~ out ~ FLAT_SPACE* ~ file) |
	(fd_out ~ in_out ~ FLAT_SPACE* ~ file) |
	(in_out ~ FLAT_SPACE* ~ file) |
	(force_out ~ FLAT_SPACE* ~ file) |
	(fd_out ~ force_out ~ FLAT_SPACE* ~ file)
}


shell_cmd = {
	for_cmd |
	match_cmd |
	loop_cmd |
	if_cmd |
	subshell |
	brace_grp |
    assignment |
	func_def
}

subsh_body = @{ (nested|non_paren)+ }
nested = _{ "(" ~ subsh_body* ~ ")"? }
non_paren = _{ (!"(" ~ !")" ~ ANY)+ }
subshell = { "(" ~ #body = subsh_body ~ ")" }
proc_sub = { (in | out) ~ "(" ~ subsh_body ~ ")" }

loop_kind = { "while" | "until" }
loop_cmd = { loop_kind ~ SPACE* ~ #cond = cmd_list ~ sep ~ "do" ~ SPACE* ~ (!"done" ~ #body = cmd_list ~ sep)+ ~ "done" ~ word_bound }

for_cmd = { "for" ~ SPACE+ ~ #vars = (!"in" ~ word ~ SPACE+)+ ~ "in" ~ SPACE+ ~ #arr = word_list ~ sep ~ "do" ~ SPACE+ ~ (!"done" ~ #body = cmd_list ~ sep)+ ~ SPACE* ~ "done" ~ word_bound }

match_pat = { (!"=>" ~ word)+ }
match_body = { (brace_grp ~ ","? | (!"," ~ ANY)+ ~ ",") }
match_arm = { match_pat ~ FLAT_SPACE* ~ "=>" ~ SPACE* ~ match_body }
match_cmd = {
	"match" ~ FLAT_SPACE* ~ #var = word ~ SPACE+ ~ "in" ~ SPACE+ ~ match_arm ~ (SPACE* ~ match_arm)* ~ SPACE* ~ "done" ~ word_bound
}

if_cmd = { "if" ~ FLAT_SPACE+ ~ #cond = cmd_list ~ sep ~ "then" ~ SPACE* ~ (!("fi" | "elif" | "else") ~ #if_body = cmd_list ~ sep)+ ~ elif_block* ~ else_block? ~ "fi" ~ word_bound }
elif_block = { "elif" ~ cmd_list ~ sep ~ "then" ~ SPACE+ ~ (!("fi" | "elif" | "else") ~ #elif_body = cmd_list ~ sep)+ }
else_block = { "else" ~ SPACE+ ~ (!("fi") ~ #else_body = cmd_list ~ sep)+ }

func_def = { word ~ "()" ~ SPACE* ~ brace_grp }

brace_grp = { "{" ~ sub_main ~ "}" }

sub_main = { SPACE* ~ cmd_list? ~ (sep ~ cmd_list?)* ~ SPACE* }
main = { SOI ~ SPACE* ~ cmd_list? ~ (sep ~ cmd_list?)* ~ SPACE* ~ EOI }
