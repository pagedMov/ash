WHITESPACE = _{ " " | "\t" }
COMMENT = { "#" ~ (!(NEWLINE|"#") ~ ANY)* }
number = { ASCII_DIGIT+ }
parameter = { "#" | ASCII_DIGIT+ | "@" | "*" | "?" | "$" | "!" | "_" | "-" }
glob_brackets = { !"\\[" ~ "[" ~ (!("]"|","|WHITESPACE|NEWLINE) ~ ANY)* ~ "]" }
glob_pat = { (!"\\?" ~ "?") | (!"\\*" ~ "*") | glob_brackets }
alpha_range_upper = @{ ASCII_ALPHA_UPPER ~ ".." ~ ASCII_ALPHA_UPPER }
alpha_range_lower = @{ ASCII_ALPHA_LOWER ~ ".." ~ ASCII_ALPHA_LOWER }
num_range = @{ ASCII_DIGIT ~ ".." ~ ASCII_DIGIT }
brace_list = @{ !"," ~ (brace_word|ident) ~ ("," ~ !"," ~ (brace_word | ident))* }
brace_expand = @{ "{" ~ (alpha_range_upper | alpha_range_lower | num_range | brace_list) ~ "}" }
path_seg = @{ path_root | path_rel }
path_root = { ("/" ~ ident)+ }
path_rel = { (ident ~ "/")+ }

//
operator = _{ WHITESPACE* ~ ("|" | "&&" | "|&" | ">" | "<" | "<<" | "<<<" | ">>" | ">|" | ">>|" | "<>" | "&") ~ WHITESPACE* }
find_expansions = { (WHITESPACE|NEWLINE|word|operator)* }

dqt = _{ "\"" }
sqt = _{ "'" }
home = { "~" }
pwd = { "~+" }
prev_pwd = { "~-" }
word_bound = _{ !ident }
string_body = { ("\\\""|!"\"" ~ ANY)* }
dquoted = _{ dqt ~ string_body ~ dqt }
squoted = _{ sqt ~ string_body ~ sqt }
var_ident = @{ NEWLINE* ~ !parameter ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-")* }
ident = _{ (("\\" ~ ANY) | (!out ~ !in ~ ASCII_ALPHANUMERIC | "\"" | "'" | "_" | "-" | "!" | "%" | "+" | "=" | "\\" | "/" | "," | "." | ":" | "@" ))+ }
glob_word = @{ ident ~ glob_pat+ ~ ident? | glob_pat+ ~ ident? }
param_sub = { "$" ~ parameter }
tilde_sub = @{ pwd | prev_pwd | (home ~ path_seg?) }
brace_word = @{ ident ~ brace_expand+ ~ ident? | brace_expand+ ~ ident? }
cmd_name = @{ word }
word = ${ dquoted | squoted | param_sub | var_sub | cmd_sub | proc_sub | glob_word | brace_word | tilde_sub | ident }
word_list = { word ~ (NEWLINE* ~ word)* }
assignment = ${ #name = var_ident ~ "=" ~ word? ~ (expr)? }
arg_assign = ${ #name = var_ident ~ "=" ~ word? }
var_sub = @{ !"\\$" ~ "$" ~ ident }
cmd_sub = ${ !"\\$" ~ "$" ~ subshell }
sep = _{ (";" | NEWLINE)+ }

simple_cmd_part = { proc_sub | redir | word }
simple_cmd = { (redir|cmd_name) ~ (redir | (arg_assign | word | redir))* }
bg_cmd = { expr ~ "&" }

pipeline = { ((shell_cmd ~ redir_list?) | simple_cmd) ~ ("|" ~ ((shell_cmd ~ redir_list?) | simple_cmd))+ }
expr = _{ pipeline | ((shell_cmd ~ redir_list?) | assignment | simple_cmd) }

and = { "&&" }
or = { "||" }
op = { (and|or) }

cmd_list = {
	(bg_cmd|expr) ~ (#op = op ~ (bg_cmd|expr))*
}

redir_list = { redir ~ (redir)* }
fd_out = @{ number }
fd_target = @{ number }
file = @{ word }
in = { "<" }
out = { ">" }
force_out = { ">|" }
in_out = { "<>" }
append = { ">>" }
heredoc = { "<<" }
herestring = { "<<<" }
redir = {
	(out ~ file) |
	(in ~ file) |
	(fd_out ~ in ~ file) |
	(fd_out ~ out ~ file) |
	(append ~ file) |
	(fd_out ~ append ~ file) |
	(heredoc ~ file) |
	(herestring ~ file) |
	(fd_out ~ heredoc ~ file) |
	(in ~ "&" ~ fd_target) |
	(fd_out ~ in ~ "&" ~ fd_target) |
	(out ~ "&" ~ fd_target) |
	(fd_out ~ out ~ "&" ~ fd_target) |
	(out ~ "&" ~ "-") |
	(fd_out ~ out ~ "&" ~ "-") |
	(fd_out ~ out ~ "&" ~ "-") |
	("&" ~ out ~ file) |
	(fd_out ~ in_out ~ file) |
	(in_out ~ file) |
	(force_out ~ file) |
	(fd_out ~ force_out ~ file)
}


shell_cmd = {
	for_cmd |
	match_cmd |
	loop_cmd |
	if_cmd |
	subshell |
	brace_grp |
    assignment |
	func_def
}

subsh_body = @{ (nested|non_paren)+ }
nested = _{ "(" ~ subsh_body* ~ ")"? }
non_paren = _{ (!"(" ~ !")" ~ ANY)+ }
subshell = { "(" ~ #body = subsh_body ~ ")" }
proc_sub = { (in | out) ~ "(" ~ subsh_body ~ ")" }

if_cond = { cmd_list }
loop_cond = { cmd_list }
if_body = { (!("fi" | "elif" | "else") ~ cmd_list ~ sep)+ }
loop_body = { (!"done" ~ cmd_list ~ sep)+ }

loop_kind = { "while" | "until" }
loop_cmd = { loop_kind ~ NEWLINE* ~ loop_cond ~ sep ~ "do" ~ NEWLINE* ~ loop_body ~ "done" ~ word_bound }

for_vars = { (!"in" ~ word ~ NEWLINE*)+ }
for_arr = { (word ~ NEWLINE*)+ }
for_cmd = { "for" ~ NEWLINE* ~ for_vars ~ "in" ~ NEWLINE* ~ for_arr+ ~ sep ~ "do" ~ NEWLINE* ~ loop_body ~ NEWLINE* ~ "done" ~ word_bound }

match_pat = { (!"=>" ~ word)+ }
match_body = { (brace_grp ~ ","? | (!"," ~ ANY)+ ~ ",") }
match_arm = { match_pat ~ "=>" ~ NEWLINE* ~ match_body }
match_cmd = {
	"match" ~ word ~ NEWLINE* ~ "in" ~ NEWLINE* ~ match_arm ~ (NEWLINE* ~ match_arm)* ~ NEWLINE* ~ "done" ~ word_bound
}

if_cmd = { "if" ~ if_cond ~ sep ~ "then" ~ NEWLINE* ~ if_body ~ elif_block* ~ else_block? ~ "fi" ~ word_bound }
elif_block = { "elif" ~ if_cond ~ sep ~ "then" ~ NEWLINE* ~ if_body }
else_block = { "else" ~ NEWLINE* ~ (!("fi") ~ #else_body = cmd_list ~ sep)+ }

func_def = { word ~ "()" ~ NEWLINE* ~ brace_grp }

brace_grp = { "{" ~ sub_main ~ "}" }

// sub_main is used for brace groups, it essentially allows for holding a script in the brace group
// It's stored as a static string, but using sub_main makes sure that it actually parses first
sub_main = _{ NEWLINE* ~ cmd_list? ~ (sep ~ cmd_list?)* ~ NEWLINE* }
main = { SOI ~ NEWLINE* ~ cmd_list? ~ (sep ~ cmd_list?)* ~ NEWLINE* ~ EOI }
